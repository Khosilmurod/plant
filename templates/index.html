<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üå± Plant Guardian</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            background: #444;
            color: white;
            overflow: hidden;
        }
        
        #threejs-viewport {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        
        .plant-status {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            background: none;
            border: none;
            z-index: 1000;
        }
        
        .sensor-buttons div {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            font-size: 16px;
            font-weight: 600;
            padding: 10px 20px;
            border-radius: 8px;
            transition: all 0.2s ease;
            text-align: center;
            min-width: 120px;
        }
        
        .status-dead {
            background: rgba(239, 68, 68, 0.12);
            border-color: rgba(239, 68, 68, 0.2);
            box-shadow: 
                0 8px 32px rgba(239, 68, 68, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
        
        .status-active {
            background: rgba(59, 130, 246, 0.12);
            border-color: rgba(59, 130, 246, 0.2);
            box-shadow: 
                0 8px 32px rgba(59, 130, 246, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
    </style>
</head>
<body>
    <canvas id="threejs-viewport"></canvas>
    
    <div class="plant-status" id="plant-status">
        <div class="sensor-buttons">
            <div id="state-display">üåø Loading...</div>
            <div id="moisture-display">üíß Connecting...</div>
        </div>
    </div>
    
    <!-- Socket.IO for real-time communication -->
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>

    <script>
        // Plant Guardian States
        const states = {
            IDLE: 'idle',
            DEAD: 'dead', 
            SWIPE: 'swipe'
        };
        
        // Sensor thresholds
        const MOISTURE_DEATH_THRESHOLD = 1500; // Raw sensor value: below 1500 = dead
        const REVIVE_DURATION = 5000; // 5 seconds of idle before dying again
        
        // Current state
        let currentState = states.IDLE;
        let moistureLevel = 60; // Start at 60% (safe level with new logic)
        let rawMoistureValue = 0; // Raw sensor value from ESP32 (0-4095)
        let lastTapTime = 0;
        let isDead = false;
        let reviveTimer = null; // Timer for temporary revival
        
        // Idle sequence tracking
        let idleSequenceIndex = 0;
        const idleSequence = ['idle_breathing', 'idle', 'idle_breathing'];
        let isPlayingIdleSequence = false;
        
        // Three.js Scene Setup
        let scene, camera, renderer, model, mixer, clock;
        let actions = {};
        let currentAction = null;
        let socket = null; // Socket.IO connection
        
        // Animation blending
        let isBlending = false;
        let blendStartTime = 0;
        let blendDuration = 0.3; // 300ms blend time
        let fromAction = null;
        let toAction = null;
        
        function smoothBlend(from, to, duration) {
            if (from === to) return;
            
            isBlending = true;
            blendStartTime = performance.now();
            blendDuration = duration * 1000; // Convert to milliseconds
            fromAction = from;
            toAction = to;
            
            // Ensure BOTH actions are enabled and playing
            if (fromAction) {
                fromAction.enabled = true;
                fromAction.setEffectiveWeight(1.0);
                fromAction.play();
            }
            if (toAction) {
                toAction.enabled = true;
                toAction.setEffectiveWeight(0.0);
                toAction.play();
            }
        }
        
        function updateBlending() {
            if (!isBlending) return;
            
            const now = performance.now();
            const elapsed = now - blendStartTime;
            const progress = Math.min(elapsed / blendDuration, 1.0);
            
            // Smooth easing function (ease-in-out)
            const eased = progress < 0.5 
                ? 2 * progress * progress 
                : 1 - Math.pow(-2 * progress + 2, 2) / 2;
            
            if (fromAction) {
                fromAction.setEffectiveWeight(1 - eased);
            }
            if (toAction) {
                toAction.setEffectiveWeight(eased);
            }
            
            // Finish blending
            if (progress >= 1.0) {
                isBlending = false;
                if (fromAction) {
                    fromAction.setEffectiveWeight(0);
                    // Keep enabled but at 0 weight for smooth future transitions
                }
                if (toAction) {
                    toAction.setEffectiveWeight(1);
                }
            }
        }
        
        function init() {
            // EXACT COPY from working debug viewer
            const canvas = document.getElementById('threejs-viewport');
            
            // Scene  
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf5f5f5);
            
            // Camera (zoomed in closer)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 3);
            
            // Renderer (EXACT same as debug viewer)
            renderer = new THREE.WebGLRenderer({ canvas: canvas });
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Lights (EXACT same as debug viewer)
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 5);
            scene.add(directionalLight);
            
            // Ground (EXACT same as debug viewer)
            const groundGeometry = new THREE.PlaneGeometry(10, 10);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            scene.add(ground);
            
            // Load model
            loadModel();
            
            // Animation loop
            animate();
            
            // Clock for animations
            clock = new THREE.Clock();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);
        }
        
        function loadModel() {
            const loader = new THREE.GLTFLoader();
            loader.load('/web_assets/npc.gltf', function(gltf) {
                console.log('üì¶ Model loaded successfully');
                
                model = gltf.scene;
                
                // EXACT COPY from working debug viewer
                const scale = 2; // Even smaller fixed scale
                model.scale.setScalar(scale);
                
                // Try different rotations to stand upright and face camera
                model.rotation.x = 0;
                model.rotation.y = 0; // No Y rotation - should face forward now
                model.rotation.z = 0;
                
                // Position properly on ground
                const box = new THREE.Box3().setFromObject(model);
                model.position.x = 0;
                model.position.z = 0;
                model.position.y = -box.min.y; // Bottom of model at ground level
                
                console.log(`Fixed scale: ${scale}`);
                
                // Make it VERY bright and visible (EXACT COPY from debug viewer)
                let meshCount2 = 0;
                model.traverse(function(child) {
                    console.log("Traversing child:", child.type, child.name);
                    if (child.isMesh) {
                        meshCount2++;
                        console.log(`Found mesh ${meshCount2}:`, child.name, "Vertices:", child.geometry.attributes.position.count);
                        
                        // Force visibility
                        child.visible = true;
                        child.frustumCulled = false;
                        
                        // Store original material and create alternatives
                        const originalMaterial = child.material;
                        const materials = [
                            originalMaterial, // Keep original first
                            new THREE.MeshLambertMaterial({ 
                                color: 0x888888, // Gray for better visibility
                                side: THREE.DoubleSide
                            }),
                            new THREE.MeshBasicMaterial({
                                color: 0x00ff00,
                                wireframe: true,
                                side: THREE.DoubleSide
                            })
                        ];
                        
                        // Start with original material
                        child.material = materials[0];
                        child.materials = materials;
                        child.materialIndex = 0;
                        
                        console.log(`Applied material to mesh: ${child.name}`);
                    }
                });
                
                console.log(`Total meshes found and processed: ${meshCount2}`);
                
                scene.add(model);
                
                // Set up animations
                if (gltf.animations && gltf.animations.length > 0) {
                    mixer = new THREE.AnimationMixer(model);
                    
                    gltf.animations.forEach((clip) => {
                        const action = mixer.clipAction(clip);
                        const name = clip.name.toLowerCase();
                        
                        console.log(`üé¨ Found animation: "${clip.name}" (${clip.tracks.length} tracks)`);
                        
                        if (name.includes('idle_animation')) {
                            actions['idle'] = action;
                            action.setLoop(THREE.LoopRepeat);
                            action.clampWhenFinished = false;
                        } else if (name.includes('layer0.001') || name.includes('breathing')) {
                            actions['idle_breathing'] = action;
                            action.setLoop(THREE.LoopRepeat);
                            action.clampWhenFinished = false;
                        } else if (name.includes('die_animation') || name.includes('die') || name.includes('death') || name.includes('dying')) {
                            actions['die'] = action;
                            action.setLoop(THREE.LoopOnce);
                            action.clampWhenFinished = true;
                        } else if (name.includes('swipe_animation') || name.includes('swipe') || name.includes('attack') || name.includes('swip')) {
                            actions['swipe'] = action;
                            action.setLoop(THREE.LoopOnce);
                            action.clampWhenFinished = true;
                        }
                    });
                    
                    // Start all animations at weight 0 for smooth crossfading
                    Object.values(actions).forEach(action => {
                        action.play();
                        action.setEffectiveWeight(0);
                        action.enabled = true;
                    });
                    
                    // Start with idle sequence
                    console.log('üé¨ Available animations:', Object.keys(actions));
                    console.log('üé¨ Animation details:');
                    Object.keys(actions).forEach(key => {
                        console.log(`  ${key}: ${actions[key].getClip().name} (${actions[key].getClip().duration.toFixed(2)}s)`);
                    });
                    playAnimation('idle');
                }
                
            }, undefined, function(error) {
                console.error('Error loading model:', error);
            });
        }
        
        function playAnimation(animationName) {
            console.log(`üé¨ playAnimation("${animationName}") called - Current state: ${currentState}`);
            
            // Handle idle sequence specially
            if (animationName === 'idle') {
                startIdleSequence();
                return;
            }
            
            // Stop idle sequence for non-idle animations
            isPlayingIdleSequence = false;
            
            if (!mixer || !actions[animationName]) {
                console.log(`‚ùå Cannot play animation: mixer=${!!mixer}, action exists=${!!actions[animationName]}`);
                return;
            }
            
            const newAction = actions[animationName];
            
            // Update state immediately based on animation
            if (animationName === 'swipe') {
                currentState = states.SWIPE;
                console.log(`‚úÖ State changed to SWIPE`);
            } else if (animationName === 'die') {
                currentState = states.DEAD;
                isDead = true;
                console.log(`‚úÖ State changed to DEAD`);
            }
            
            // Clear any switch timer from previous action
            if (currentAction && currentAction.switchTimer) {
                clearTimeout(currentAction.switchTimer);
                currentAction.switchTimer = null;
            }
            
            // Clear any blend timer from previous action
            if (currentAction && currentAction.blendTimer) {
                clearTimeout(currentAction.blendTimer);
                currentAction.blendTimer = null;
            }
            
            // For one-shot animations, reset them
            if (animationName === 'swipe') {
                newAction.reset();
                newAction.time = 0;
                newAction.enabled = true;
                newAction.setLoop(THREE.LoopOnce);
                newAction.clampWhenFinished = false; // Don't clamp - smooth blend out
            } else if (animationName === 'die') {
                newAction.reset();
                newAction.time = 0;
                newAction.enabled = true;
                newAction.setLoop(THREE.LoopOnce);
                newAction.clampWhenFinished = true; // Clamp to hold dead pose
            }
            
            // Smooth blend from current to new action
            // Use faster blend when coming from swipe (0.3s for swipe itself, 0.5s when transitioning from swipe)
            let blendTime = 0.7; // Default for normal transitions
            if (animationName === 'swipe') {
                blendTime = 0.3; // Fast blend into swipe
            } else if (animationName === 'die' && currentAction === actions['swipe']) {
                blendTime = 0.5; // Faster blend from swipe to die
            }
            
            smoothBlend(currentAction, newAction, blendTime);
            
            currentAction = newAction;
            
            // Set up animation finished listener for swipe animation
            if (animationName === 'swipe') {
                // Calculate when to start blending to next animation (before swipe fully finishes)
                const swipeDuration = newAction.getClip().duration * 1000; // Convert to ms
                const blendStartOffset = 500; // Start blending 500ms before swipe ends (earlier!)
                
                const blendTimer = setTimeout(() => {
                    console.log('‚úÖ Swipe animation about to finish - starting blend to next state');
                    checkMoistureLevel();
                }, Math.max(0, swipeDuration - blendStartOffset));
                
                // Store timer to clean up if needed
                newAction.blendTimer = blendTimer;
            }
            
            updateUI();
        }
        
        function startIdleSequence() {
            console.log('üîÑ Starting idle sequence');
            isPlayingIdleSequence = true;
            idleSequenceIndex = 0;
            currentState = states.IDLE;
            isDead = false;
            playNextIdleAnimation();
        }
        
        function playNextIdleAnimation() {
            if (!isPlayingIdleSequence) return;
            
            const animName = idleSequence[idleSequenceIndex];
            console.log(`üé≠ Playing idle sequence ${idleSequenceIndex + 1}/3: ${animName}`);
            
            if (!actions[animName]) {
                console.error(`‚ùå Animation not found: ${animName}`);
                return;
            }
            
            const newAction = actions[animName];
            
            // Clear any existing switch timer
            if (currentAction && currentAction.switchTimer) {
                clearTimeout(currentAction.switchTimer);
                currentAction.switchTimer = null;
            }
            
            // Use faster blend when transitioning from swipe (0.5s), shorter for idle-to-idle (0.5s)
            const wasSwipe = currentAction === actions['swipe'];
            const blendTime = wasSwipe ? 0.5 : 0.5; // Faster idle-to-idle transitions
            
            // Set weights: new action to 1, all others to 0
            smoothBlend(currentAction, newAction, blendTime);
            
            currentAction = newAction;
            
            // Set up timer to switch to next animation BEFORE it ends (overlap for smooth transition)
            const animationDuration = 4000; // 4 seconds per idle animation
            const blendStartOffset = 500; // Start blending 500ms before switching
            
            const switchTimer = setTimeout(() => {
                if (isPlayingIdleSequence) {
                    // Move to next in sequence
                    idleSequenceIndex = (idleSequenceIndex + 1) % idleSequence.length;
                    playNextIdleAnimation();
                }
            }, animationDuration - blendStartOffset); // Start blend earlier
            
            // Store timer so we can clear it if needed
            currentAction.switchTimer = switchTimer;
            
            updateUI();
        }
        
        function updateUI() {
            const stateDisplay = document.getElementById('state-display');
            const moistureDisplay = document.getElementById('moisture-display');
            
            // Update state display
            if (currentState === states.DEAD || currentState === 'die') {
                stateDisplay.textContent = 'üíÄ Dead';
                stateDisplay.style.borderColor = 'rgba(239, 68, 68, 0.5)';
            } else if (currentState === states.SWIPE || currentState === 'swipe') {
                stateDisplay.textContent = '‚öîÔ∏è Defending';
                stateDisplay.style.borderColor = 'rgba(234, 179, 8, 0.5)';
            } else {
                stateDisplay.textContent = 'üåø Alive';
                stateDisplay.style.borderColor = 'rgba(34, 197, 94, 0.5)';
            }
            
            // Update moisture display with raw sensor value
            moistureDisplay.textContent = `${rawMoistureValue} üíß`;
            console.log(`üé® UI updated - State: ${currentState}, Moisture: ${rawMoistureValue} üíß`);
        }
        
        function handleTap() {
            console.log(`üéØ handleTap() - Current State: ${currentState}, Moisture: ${moistureLevel}%`);
            
            // Always play swipe animation on tap
            playAnimation('swipe');
        }
        
        function checkMoistureLevel() {
            console.log(`üîç Checking moisture: ${rawMoistureValue} raw (${moistureLevel.toFixed(1)}%) - threshold: ${MOISTURE_DEATH_THRESHOLD}`);
            console.log(`üîç Current state: ${currentState}, isDead: ${isDead}`);
            
            if (rawMoistureValue < MOISTURE_DEATH_THRESHOLD) {
                // Moisture is low (< 1500 raw) - should be dead
                if (currentState !== states.DEAD && currentState !== 'die') {
                    console.log(`üíÄ Moisture LOW (${rawMoistureValue} < ${MOISTURE_DEATH_THRESHOLD}) - transitioning to DEAD state`);
                    isDead = true;
                    playAnimation('die');
                }
            } else {
                // Moisture is good (>= 1500 raw) - should be alive/idle
                if (currentState !== states.IDLE && currentState !== 'idle') {
                    console.log(`üå± Moisture GOOD (${rawMoistureValue} >= ${MOISTURE_DEATH_THRESHOLD}) - transitioning to IDLE state`);
                    isDead = false;
                    playAnimation('idle');
                }
            }
        }
        
        // Button event listeners
        function setupButtons() {
            // No buttons anymore - just display divs
            console.log('üìä Display elements initialized');
        }
        
        // Controls
        document.addEventListener('keydown', function(event) {
            // Tap controls disabled - only sensor can trigger
            // Space and Enter keys disabled for production
        });
        
        // Mouse wheel zoom
        document.getElementById('threejs-viewport').addEventListener('wheel', function(event) {
            event.preventDefault();
            const zoomSpeed = 0.1;
            const direction = event.deltaY > 0 ? 1 : -1;
            
            camera.position.z += direction * zoomSpeed;
            camera.position.z = Math.max(1.5, Math.min(8, camera.position.z)); // Clamp zoom (closer limits)
        });
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Update blending
            updateBlending();
            
            // Update animations
            if (mixer) {
                mixer.update(clock.getDelta());
            }
            
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Initialize when page loads
        window.addEventListener('load', function() {
            console.log('üå± Plant Guardian initializing...');
            init();
            setupButtons();
            setupSocketIO();
            
            // Test socket connection after 2 seconds
            setTimeout(() => {
                if (socket && socket.connected) {
                    console.log('‚úÖ Socket is connected:', socket.id);
                    console.log('‚úÖ Transport:', socket.io.engine.transport.name);
                } else {
                    console.error('‚ùå Socket is NOT connected!');
                    console.error('Socket exists?', !!socket);
                    if (socket) {
                        console.error('Socket connected?', socket.connected);
                        console.error('Socket disconnected?', socket.disconnected);
                    }
                }
            }, 2000);
            
            console.log('üå± Plant Guardian initialized - waiting for sensor data...');
        });
        
        // Socket.IO connection for real-time MQTT data
        function setupSocketIO() {
            console.log('üîå Setting up Socket.IO connection...');
            
            // Create socket connection with explicit options
            socket = io({
                transports: ['websocket', 'polling'],
                reconnection: true,
                reconnectionDelay: 1000,
                reconnectionAttempts: 5
            });
            
            socket.on('connect', function() {
                console.log('‚úÖ Connected to server - Socket ID:', socket.id);
                console.log('üîó Transport:', socket.io.engine.transport.name);
            });
            
            socket.on('connect_error', function(error) {
                console.error('‚ùå Connection error:', error.message);
            });
            
            socket.on('disconnect', function(reason) {
                console.log('‚ùå Disconnected:', reason);
            });
            
            // Debug: Log ALL Socket.IO events
            socket.onAny((eventName, ...args) => {
                console.log(`üîî Event: "${eventName}"`, args);
            });
            
            // Handle moisture updates
            socket.on('moisture_update', function(data) {
                console.log(`üíß MOISTURE UPDATE:`, data);
                
                if (!data || data.value === undefined) {
                    console.error('‚ùå Invalid moisture data received');
                    return;
                }
                
                // Store raw sensor value and percentage
                rawMoistureValue = data.value;
                moistureLevel = data.percent;
                
                console.log(`‚úÖ Updated: rawMoistureValue=${rawMoistureValue}, moistureLevel=${moistureLevel}%`);
                
                // Check if state changed
                if (data.changed) {
                    console.log('üîÑ State changed - checking moisture level');
                    checkMoistureLevel();
                }
                
                updateUI();
            });
            
            // Handle tap events  
            socket.on('tap_event', function(data) {
                console.log('='.repeat(60));
                console.log('üí• TAP EVENT RECEIVED!');
                console.log('üì¶ Data:', data);
                console.log('üé≠ Current State:', currentState);
                console.log('üíß Moisture:', moistureLevel + '%');
                console.log('='.repeat(60));
                
                // Trigger tap animation immediately
                handleTap();
            });
            
            console.log('‚úÖ Socket.IO handlers registered');
        }
    </script>
</body>
</html>